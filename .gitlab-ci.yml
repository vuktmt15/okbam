stages:
  - cache
  - quality_check
  - package
  - deploy

variables:
  DEPLOY_ENV: dev
  GITLAB_ENV: dev
  FF_USE_FASTZIP: "true"
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  CACHE_COMPRESSION_LEVEL: "fast"
  SEND_MESSAGE_TO_SLACK: "curl -X POST -H 'Content-type: application/json' $SLACK_WEBHOOK_URL --data"
  IMAGE_NAME: $REGISTRY_URL/$REGISTRY_USERNAME/$CI_PROJECT_NAME

default:
  image: node:20-alpine
  tags:
    - docker

workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == "production"
      variables:
        GITLAB_ENV: prod
        DEPLOY_ENV: prod
    - when: always

.node_modules-cache: &node_modules-cache # Cache node_modules
  key:
    files:
      - yarn.lock
  paths:
    - node_modules
  policy: pull

.run-on-merge-request: &run-on-merge-request
  if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME == $CI_COMMIT_REF_NAME'

.run-on-prod: &run-on-prod
  if: "$CI_COMMIT_REF_NAME == 'production'"

.run-on-dev: &run-on-dev
  if: "$CI_COMMIT_REF_NAME == 'develop'"

.run-on-staging: &run-on-staging
  if: "$CI_COMMIT_REF_NAME == 'staging'"

.run-on-default-branch: &run-on-default-branch # Run job on main branch
  if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"

.run-on-product-tag: &run-on-product-tag # Run job when create tag on main branch
  if: "$CI_COMMIT_TAG =~ /^v\\d+.\\d+.\\d+/"

cache-main:
  stage: cache
  cache:
    - <<: *node_modules-cache
      policy: pull-push # We override the policy
  rules:
    - <<: *run-on-merge-request
    - <<: *run-on-dev
      when: manual
    - <<: *run-on-prod
      when: manual
    - <<: *run-on-default-branch
      when: manual
  environment: $GITLAB_ENV
  script:
    - yarn bootstrap --cache-folder .yarn

test-main:
  stage: quality_check
  needs: ["cache-main"]
  cache:
    - <<: *node_modules-cache
  rules:
    - <<: *run-on-merge-request
    - <<: *run-on-dev
    - <<: *run-on-prod
    - <<: *run-on-default-branch
  environment: $GITLAB_ENV
  dependencies:
    - cache-main
  script:
    - yarn lint
    - yarn prettier
    - yarn check-types
    - yarn test

sonarqube:
  stage: quality_check
  image:
    name: sonarsource/sonar-scanner-cli:5.0
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
    GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  rules:
    - <<: *run-on-dev
    - <<: *run-on-prod
    - <<: *run-on-staging
    - <<: *run-on-default-branch
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
  allow_failure: true

package_docker:
  stage: package
  image: docker
  services:
    - docker:dind
  environment: $GITLAB_ENV
  needs: ["test-main"]
  before_script:
    - docker info
    - docker login $REGISTRY_URL -u $REGISTRY_USERNAME -p $REGISTRY_PASSWORD
  rules:
    - <<: *run-on-dev
    - <<: *run-on-prod
    - <<: *run-on-default-branch
  script:
    - docker build -f docker/$DEPLOY_ENV/Dockerfile -t $IMAGE_NAME:$CI_COMMIT_SHORT_SHA -t $IMAGE_NAME:latest .
    - docker push $IMAGE_NAME:$CI_COMMIT_SHORT_SHA
    - docker push $IMAGE_NAME:latest

deploy_dev:
  image: alpine:latest
  stage: deploy
  rules:
    - <<: *run-on-dev
  environment: $GITLAB_ENV
  needs: ["package_docker"]
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
  script:
    - ssh -o StrictHostKeyChecking=no $SSH_USERNAME@$SSH_HOST -p $SSH_PORT "docker login -u $REGISTRY_USERNAME -p $REGISTRY_PASSWORD"
    - ssh -o StrictHostKeyChecking=no $SSH_USERNAME@$SSH_HOST -p $SSH_PORT "cd $PATH_TO_PROJECT && docker compose pull"
    - ssh -o StrictHostKeyChecking=no $SSH_USERNAME@$SSH_HOST -p $SSH_PORT "cd $PATH_TO_PROJECT && docker compose up -d"
    - ssh -o StrictHostKeyChecking=no $SSH_USERNAME@$SSH_HOST -p $SSH_PORT "docker image prune -af"